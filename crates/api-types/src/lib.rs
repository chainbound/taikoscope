//! Data types for the Taikoscope API.
//!
//! These structs define the JSON responses returned by the API server. They
//! are provided in a separate crate so that consumers such as the dashboard can
//! depend on them without pulling in the rest of the server implementation.

use clickhouse_lib::{
    BatchBlobCountRow, BatchPostingTimeRow, BatchProveTimeRow, BatchVerifyTimeRow,
    ForcedInclusionProcessedRow, L1BlockTimeRow, L2BlockTimeRow, L2GasUsedRow, L2ReorgRow,
    MissedBlockProposalRow, SlashingEventRow,
};

use axum::{Json, http::StatusCode, response::IntoResponse};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Error response following a condensed version of RFC 7807.
///
/// This structure is returned when API calls fail and provides
/// machine readable details about the error. The `type` field uses a
/// short identifier instead of a full URL.
#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ErrorResponse {
    /// Identifier for the error type.
    #[serde(rename = "type")]
    pub r#type: String,
    /// Short, human readable summary of the problem.
    pub title: String,
    /// HTTP status code generated by the server.
    pub status: u16,
    /// Detailed information specific to this occurrence of the problem.
    pub detail: String,
}

impl ErrorResponse {
    /// Create a new [`ErrorResponse`].
    pub fn new(
        r#type: impl Into<String>,
        title: impl Into<String>,
        status: StatusCode,
        detail: impl Into<String>,
    ) -> Self {
        Self {
            r#type: r#type.into(),
            title: title.into(),
            status: status.as_u16(),
            detail: detail.into(),
        }
    }
}

impl IntoResponse for ErrorResponse {
    fn into_response(self) -> axum::response::Response {
        let status = StatusCode::from_u16(self.status).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);
        (status, Json(self)).into_response()
    }
}

/// Basic health status response.
#[derive(Debug, Serialize, ToSchema)]
pub struct HealthResponse {
    /// Health status string.
    pub status: String,
}

/// Timestamp of the most recent L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2HeadResponse {
    /// Time when the last L2 block was produced.
    pub last_l2_head_time: Option<String>,
}

/// Timestamp of the most recent L1 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1HeadResponse {
    /// Time when the last L1 block was produced.
    pub last_l1_head_time: Option<String>,
}

/// List of validator slashing events.
#[derive(Debug, Serialize, ToSchema)]
pub struct SlashingEventsResponse {
    /// List of slashing event rows.
    pub events: Vec<SlashingEventRow>,
}

/// Forced inclusion events that were processed.
#[derive(Debug, Serialize, ToSchema)]
pub struct ForcedInclusionEventsResponse {
    /// Forced inclusion events that were processed.
    pub events: Vec<ForcedInclusionProcessedRow>,
}

/// Detected L2 reorg events.
#[derive(Debug, Serialize, ToSchema)]
pub struct ReorgEventsResponse {
    /// Detected L2 reorg events.
    pub events: Vec<L2ReorgRow>,
}

/// Missed block proposal events.
#[derive(Debug, Serialize, ToSchema)]
pub struct MissedBlockProposalsResponse {
    /// Missed block proposal rows.
    pub events: Vec<MissedBlockProposalRow>,
}

/// Gateways that submitted batches in the requested range.
#[derive(Debug, Serialize, ToSchema)]
pub struct ActiveGatewaysResponse {
    /// Gateways that submitted batches in the requested range.
    pub gateways: Vec<String>,
}

/// Current operator address.
#[derive(Debug, Serialize, ToSchema)]
pub struct CurrentOperatorResponse {
    /// Current operator address, if any.
    pub operator: Option<String>,
}

/// Address of the next operator.
#[derive(Debug, Serialize, ToSchema)]
pub struct NextOperatorResponse {
    /// Address of the next operator, if configured.
    pub operator: Option<String>,
}

/// Preconfiguration data containing sequencer candidates and operators.
#[derive(Debug, Serialize, ToSchema)]
pub struct PreconfDataResponse {
    /// Candidates included in the latest preconfiguration.
    pub candidates: Vec<String>,
    /// Current operator address, if any.
    pub current_operator: Option<String>,
    /// Address of the next operator, if configured.
    pub next_operator: Option<String>,
}

/// Average time in milliseconds to prove a batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgProveTimeResponse {
    /// Average time in milliseconds to prove a batch.
    pub avg_prove_time_ms: Option<u64>,
}

/// Average time in milliseconds to verify a batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgVerifyTimeResponse {
    /// Average time in milliseconds to verify a batch.
    pub avg_verify_time_ms: Option<u64>,
}

/// Average delay between L2 blocks in milliseconds.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2BlockCadenceResponse {
    /// Average delay between L2 blocks in milliseconds.
    pub l2_block_cadence_ms: Option<u64>,
}

/// Average delay between batch submissions.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchPostingCadenceResponse {
    /// Average delay between batch submissions in milliseconds.
    pub batch_posting_cadence_ms: Option<u64>,
}

/// Average L2 transactions per second.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgL2TpsResponse {
    /// Average L2 transactions per second.
    pub avg_tps: Option<f64>,
}

/// Total L2 transaction fee.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2TxFeeResponse {
    /// Sum of priority fee and 75% of base fee for the range.
    pub tx_fee: Option<u128>,
}

/// Estimated cloud infrastructure cost in USD.
#[derive(Debug, Serialize, ToSchema)]
pub struct CloudCostResponse {
    /// Estimated infrastructure cost in USD for the requested range.
    pub cost_usd: f64,
}

/// Estimated prover infrastructure cost in USD.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProverCostResponse {
    /// Estimated prover cost in USD for the requested range.
    pub cost_usd: f64,
}

/// Time to prove individual batches.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProveTimesResponse {
    /// Time to prove individual batches.
    pub batches: Vec<BatchProveTimeRow>,
}

/// Time to verify individual batches.
#[derive(Debug, Serialize, ToSchema)]
pub struct VerifyTimesResponse {
    /// Time to verify individual batches.
    pub batches: Vec<BatchVerifyTimeRow>,
}

/// L1 block numbers grouped by minute.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1BlockTimesResponse {
    /// L1 block numbers grouped by minute.
    pub blocks: Vec<L1BlockTimeRow>,
}

/// Timestamp data for L2 blocks.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2BlockTimesResponse {
    /// Timestamp data for L2 blocks.
    pub blocks: Vec<L2BlockTimeRow>,
}

/// Gas usage for each L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2GasUsedResponse {
    /// Gas usage for each L2 block.
    pub blocks: Vec<L2GasUsedRow>,
}

/// Number of blocks produced by a sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerDistributionItem {
    /// Sequencer address.
    pub address: String,
    /// Number of blocks produced by the sequencer.
    pub blocks: u64,
}

/// Distribution of blocks across sequencers.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerDistributionResponse {
    /// Distribution of blocks across sequencers.
    pub sequencers: Vec<SequencerDistributionItem>,
}

/// Blocks proposed by a sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerBlocksItem {
    /// Sequencer address.
    pub address: String,
    /// Blocks proposed by the sequencer.
    pub blocks: Vec<u64>,
}

/// Mapping of sequencers to their blocks.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerBlocksResponse {
    /// Mapping of sequencers to their blocks.
    pub sequencers: Vec<SequencerBlocksItem>,
}

/// Transaction count for a block and its sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockTransactionsItem {
    /// Block number.
    pub block: u64,
    /// Number of transactions in the block.
    pub txs: u32,
    /// Address of the sequencer that proposed the block.
    pub sequencer: String,
}

/// Collection of block transaction counts.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockTransactionsResponse {
    /// Collection of block transaction counts.
    pub blocks: Vec<BlockTransactionsItem>,
}

/// Blob count per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchBlobsResponse {
    /// Blob count per batch.
    pub batches: Vec<BatchBlobCountRow>,
}

/// Average number of blobs per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgBlobsPerBatchResponse {
    /// Average number of blobs per batch.
    pub avg_blobs: Option<f64>,
}

/// Interval between consecutive batch postings.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchPostingTimesResponse {
    /// Interval data for each batch.
    pub batches: Vec<BatchPostingTimeRow>,
}

/// Number of the most recent L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2HeadBlockResponse {
    /// Number of the most recent L2 block.
    pub l2_head_block: Option<u64>,
}

/// Number of the most recent L1 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1HeadBlockResponse {
    /// Number of the most recent L1 block.
    pub l1_head_block: Option<u64>,
}
