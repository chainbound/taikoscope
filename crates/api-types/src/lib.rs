//! Data types for the Taikoscope API.
//!
//! These structs define the JSON responses returned by the API server. They
//! are provided in a separate crate so that consumers such as the dashboard can
//! depend on them without pulling in the rest of the server implementation.
#![allow(clippy::uninlined_format_args)]
#![allow(clippy::cognitive_complexity)]

use clickhouse_lib::{
    BatchBlobCountRow, BatchPostingTimeRow, BatchProveTimeRow, BatchVerifyTimeRow,
    BlockFeeComponentRow, ForcedInclusionProcessedRow, L1BlockTimeRow, L1DataCostRow,
    L2BlockTimeRow, L2GasUsedRow, L2TpsRow, ProveCostRow, SlashingEventRow,
};

use axum::{Json, http::StatusCode, response::IntoResponse};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Error response following a condensed version of RFC 7807.
///
/// This structure is returned when API calls fail and provides
/// machine readable details about the error. The `type` field uses a
/// short identifier instead of a full URL.
#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ErrorResponse {
    /// Identifier for the error type.
    #[serde(rename = "type")]
    pub r#type: String,
    /// Short, human readable summary of the problem.
    pub title: String,
    /// HTTP status code generated by the server.
    pub status: u16,
    /// Detailed information specific to this occurrence of the problem.
    pub detail: String,
}

impl ErrorResponse {
    /// Create a new [`ErrorResponse`].
    pub fn new(
        r#type: impl Into<String>,
        title: impl Into<String>,
        status: StatusCode,
        detail: impl Into<String>,
    ) -> Self {
        Self {
            r#type: r#type.into(),
            title: title.into(),
            status: status.as_u16(),
            detail: detail.into(),
        }
    }

    /// Create a generic database error without exposing internals.
    pub fn database_error() -> Self {
        Self::new(
            "database-error",
            "Database error",
            StatusCode::INTERNAL_SERVER_ERROR,
            "internal error",
        )
    }
}

impl IntoResponse for ErrorResponse {
    fn into_response(self) -> axum::response::Response {
        let status = StatusCode::from_u16(self.status).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);
        (status, Json(self)).into_response()
    }
}

/// Basic health status response.
#[derive(Debug, Serialize, ToSchema)]
pub struct HealthResponse {
    /// Health status string.
    pub status: String,
}

/// Timestamp of the most recent L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2HeadResponse {
    /// Time when the last L2 block was produced.
    pub last_l2_head_time: Option<String>,
}

/// Timestamp of the most recent L1 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1HeadResponse {
    /// Time when the last L1 block was produced.
    pub last_l1_head_time: Option<String>,
}

/// List of validator slashing events.
#[derive(Debug, Serialize, ToSchema)]
pub struct SlashingEventsResponse {
    /// List of slashing event rows.
    pub events: Vec<SlashingEventRow>,
}

/// Forced inclusion events that were processed.
#[derive(Debug, Serialize, ToSchema)]
pub struct ForcedInclusionEventsResponse {
    /// Forced inclusion events that were processed.
    pub events: Vec<ForcedInclusionProcessedRow>,
}

/// Single L2 reorg event with sequencer addresses.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2ReorgEvent {
    /// Block number that became the new head.
    pub l2_block_number: u64,
    /// Number of blocks replaced by the reorg.
    pub depth: u16,
    /// Address of the sequencer that produced the replaced block.
    pub old_sequencer: String,
    /// Address of the sequencer that produced the new block.
    pub new_sequencer: String,
    /// Time the reorg was recorded.
    pub inserted_at: DateTime<Utc>,
}

/// Detected L2 reorg events.
#[derive(Debug, Serialize, ToSchema)]
pub struct ReorgEventsResponse {
    /// Detected L2 reorg events.
    pub events: Vec<L2ReorgEvent>,
}

/// Gateways that submitted batches in the requested range.
#[derive(Debug, Serialize, ToSchema)]
pub struct ActiveGatewaysResponse {
    /// Gateways that submitted batches in the requested range.
    pub gateways: Vec<String>,
}

/// Current operator address.
#[derive(Debug, Serialize, ToSchema)]
pub struct CurrentOperatorResponse {
    /// Current operator address, if any.
    pub operator: Option<String>,
}

/// Address of the next operator.
#[derive(Debug, Serialize, ToSchema)]
pub struct NextOperatorResponse {
    /// Address of the next operator, if configured.
    pub operator: Option<String>,
}

/// Preconfiguration data containing sequencer candidates and operators.
#[derive(Debug, Serialize, ToSchema)]
pub struct PreconfDataResponse {
    /// Candidates included in the latest preconfiguration.
    pub candidates: Vec<String>,
    /// Current operator address, if any.
    pub current_operator: Option<String>,
    /// Address of the next operator, if configured.
    pub next_operator: Option<String>,
}

/// Average time in milliseconds to prove a batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgProveTimeResponse {
    /// Average time in milliseconds to prove a batch.
    pub avg_prove_time_ms: Option<u64>,
}

/// Average delay between L2 blocks in milliseconds.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2BlockCadenceResponse {
    /// Average delay between L2 blocks in milliseconds.
    pub l2_block_cadence_ms: Option<u64>,
}

/// Average delay between batch submissions.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchPostingCadenceResponse {
    /// Average delay between batch submissions in milliseconds.
    pub batch_posting_cadence_ms: Option<u64>,
}

/// Average L2 transactions per second.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgL2TpsResponse {
    /// Average L2 transactions per second.
    pub avg_tps: Option<f64>,
}

/// Total L2 fees broken down by component.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2FeesResponse {
    /// Sum of priority fees for the range.
    pub priority_fee: Option<u128>,
    /// Sum of base fees for the range.
    pub base_fee: Option<u128>,
    /// Total L1 data posting cost for the range.
    pub l1_data_cost: u128,
    /// Total proving cost for the range.
    pub prove_cost: u128,
    /// Fee breakdown for each sequencer.
    pub sequencers: Vec<SequencerFeeRow>,
}

/// Estimated cloud infrastructure cost in USD.
#[derive(Debug, Serialize, ToSchema)]
pub struct CloudCostResponse {
    /// Estimated infrastructure cost in USD for the requested range.
    pub cost_usd: f64,
}

/// Time to prove individual batches.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProveTimesResponse {
    /// Time to prove individual batches.
    pub batches: Vec<BatchProveTimeRow>,
}

/// Time to verify individual batches.
#[derive(Debug, Serialize, ToSchema)]
pub struct VerifyTimesResponse {
    /// Time to verify individual batches.
    pub batches: Vec<BatchVerifyTimeRow>,
}

/// L1 block numbers grouped by minute.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1BlockTimesResponse {
    /// L1 block numbers grouped by minute.
    pub blocks: Vec<L1BlockTimeRow>,
}

/// Timestamp data for L2 blocks.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2BlockTimesResponse {
    /// Timestamp data for L2 blocks.
    pub blocks: Vec<L2BlockTimeRow>,
}

/// Gas usage for each L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2GasUsedResponse {
    /// Gas usage for each L2 block.
    pub blocks: Vec<L2GasUsedRow>,
}

/// L1 data posting cost per block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1DataCostResponse {
    /// Cost per block.
    pub blocks: Vec<L1DataCostRow>,
}

/// Prover cost per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProveCostResponse {
    /// Cost information for each proved batch.
    pub batches: Vec<ProveCostRow>,
}

/// Fee components for each L2 block
#[derive(Debug, Serialize, ToSchema)]
pub struct FeeComponentsResponse {
    /// Fee components per block
    pub blocks: Vec<BlockFeeComponentRow>,
}

/// Fee components for a batch
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchFeeComponentRow {
    /// Batch ID
    pub batch_id: u64,
    /// L1 block number that included the batch
    pub l1_block_number: u64,
    /// Transaction hash that proposed the batch
    pub l1_tx_hash: String,
    /// Sequencer address that proposed the batch
    pub sequencer: String,
    /// Total priority fee for the batch
    pub priority_fee: u128,
    /// Total base fee for the batch
    pub base_fee: u128,
    /// L1 data posting cost associated with the batch, if available
    pub l1_data_cost: Option<u128>,
    /// Prover cost amortized across batches in the selected range
    pub amortized_prove_cost: Option<u128>,
}

/// Fee components for each batch
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchFeeComponentsResponse {
    /// Fee components per batch
    pub batches: Vec<BatchFeeComponentRow>,
}

/// TPS values for each L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2TpsResponse {
    /// TPS values for each L2 block.
    pub blocks: Vec<L2TpsRow>,
}

/// Number of blocks produced by a sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerDistributionItem {
    /// Sequencer address.
    pub address: String,
    /// Number of blocks produced by the sequencer.
    pub blocks: u64,
    /// Average transactions per second for the sequencer in the selected range.
    pub tps: Option<f64>,
}

/// Distribution of blocks across sequencers.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerDistributionResponse {
    /// Distribution of blocks across sequencers.
    pub sequencers: Vec<SequencerDistributionItem>,
}

/// Blocks proposed by a sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerBlocksItem {
    /// Sequencer address.
    pub address: String,
    /// Blocks proposed by the sequencer.
    pub blocks: Vec<u64>,
}

/// Mapping of sequencers to their blocks.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerBlocksResponse {
    /// Mapping of sequencers to their blocks.
    pub sequencers: Vec<SequencerBlocksItem>,
}

/// Transaction count for a block.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockTransactionsItem {
    /// Block number.
    pub block_number: u64,
    /// Number of transactions in the block.
    pub txs: u32,
    /// Timestamp of the block.
    pub block_time: DateTime<Utc>,
}

/// Collection of block transaction counts.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockTransactionsResponse {
    /// Collection of block transaction counts.
    pub blocks: Vec<BlockTransactionsItem>,
}

/// Profit information for a block.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockProfitItem {
    /// Block number.
    pub block_number: u64,
    /// Profit in gwei (priority + base - L1 cost).
    pub profit: i128,
}

/// Collection of block profit entries.
#[derive(Debug, Serialize, ToSchema)]
pub struct BlockProfitsResponse {
    /// Profit entries for the requested range.
    pub blocks: Vec<BlockProfitItem>,
}

/// Aggregated cost attributed to a proposer.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProposerCostItem {
    /// Proposer address.
    pub address: String,
    /// Total cost in gwei.
    pub cost: u128,
}

/// Aggregated cost results grouped by proposer.
#[derive(Debug, Serialize, ToSchema)]
pub struct ProposerCostsResponse {
    /// Cost entries for each proposer.
    pub proposers: Vec<ProposerCostItem>,
}

/// Aggregated L2 fees for a sequencer.
#[derive(Debug, Serialize, ToSchema)]
pub struct SequencerFeeRow {
    /// Sequencer address.
    pub address: String,
    /// Sum of priority fees for the sequencer.
    pub priority_fee: u128,
    /// Sum of base fees for the sequencer.
    pub base_fee: u128,
    /// Total L1 data posting cost for the sequencer.
    pub l1_data_cost: u128,
    /// Total proving cost for the sequencer.
    pub prove_cost: u128,
}

/// Blob count per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchBlobsResponse {
    /// Blob count per batch.
    pub batches: Vec<BatchBlobCountRow>,
}

/// Aggregated blob count per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgBatchBlobCountRow {
    /// L1 block number
    pub l1_block_number: u64,
    /// Batch ID
    pub batch_id: u64,
    /// Average number of blobs in the bucket
    pub blob_count: f64,
}

/// Aggregated blob count per batch response.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgBatchBlobsResponse {
    /// Aggregated blob count per batch.
    pub batches: Vec<AvgBatchBlobCountRow>,
}

/// Mapping entry of a batch to its corresponding L1 block number.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchBlockItem {
    /// Batch ID
    pub batch: u64,
    /// L1 block number that included the batch
    pub block_number: u64,
}

/// Mapping of batches to their corresponding L1 block number.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchBlocksResponse {
    /// Mapping entries for each batch.
    pub batches: Vec<BatchBlockItem>,
}

/// Average number of blobs per batch.
#[derive(Debug, Serialize, ToSchema)]
pub struct AvgBlobsPerBatchResponse {
    /// Average number of blobs per batch.
    pub avg_blobs: Option<f64>,
}

/// Interval between consecutive batch postings.
#[derive(Debug, Serialize, ToSchema)]
pub struct BatchPostingTimesResponse {
    /// Interval data for each batch.
    pub batches: Vec<BatchPostingTimeRow>,
}

/// Number of the most recent L2 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L2HeadBlockResponse {
    /// Number of the most recent L2 block.
    pub l2_head_block: Option<u64>,
}

/// Number of the most recent L1 block.
#[derive(Debug, Serialize, ToSchema)]
pub struct L1HeadBlockResponse {
    /// Number of the most recent L1 block.
    pub l1_head_block: Option<u64>,
}

/// Aggregated data for the main dashboard.
#[derive(Debug, Serialize, ToSchema)]
pub struct DashboardDataResponse {
    /// Average delay between L2 blocks in milliseconds.
    pub l2_block_cadence_ms: Option<u64>,
    /// Average delay between batch submissions in milliseconds.
    pub batch_posting_cadence_ms: Option<u64>,
    /// Average time to prove a batch in milliseconds.
    pub avg_prove_time_ms: Option<u64>,
    /// Average time to verify a batch in milliseconds.
    pub avg_verify_time_ms: Option<u64>,
    /// Average L2 transactions per second.
    pub avg_tps: Option<f64>,
    /// Latest preconfiguration data.
    pub preconf_data: Option<PreconfDataResponse>,
    /// Number of L2 reorg events in the selected range.
    pub l2_reorgs: usize,
    /// Number of slashing events in the selected range.
    pub slashings: usize,
    /// Number of forced inclusion events in the selected range.
    pub forced_inclusions: usize,
    /// Number of the most recent L2 block.
    pub l2_head_block: Option<u64>,
    /// Number of the most recent L1 block.
    pub l1_head_block: Option<u64>,
}

/// Current ETH price in USD.
#[derive(Debug, Serialize, ToSchema)]
pub struct EthPriceResponse {
    /// Price of ETH in USD.
    pub price: f64,
}
